const utils = require('./utils')
const solc = require('solc')

const GnosisSafe = artifacts.require("./GnosisSafePersonalEdition.sol")
const ProxyFactory = artifacts.require("./ProxyFactory.sol")
const MultiSend = artifacts.require("./MultiSend.sol")
const TransactionWrapper = web3.eth.contract([{"constant":false,"inputs":[{"name":"to","type":"address"},{"name":"value","type":"uint256"},{"name":"data","type":"bytes"}],"name":"send","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]);
        

contract('GnosisSafe', function(accounts) {

    let gnosisSafe1
    let gnosisSafe2
    let multiSend
    let lw
    let executor = accounts[8]

    const MAX_GAS_PRICE = web3.toWei(100, 'gwei')

    const DELEGATECALL = 1

    let executeTransaction = async function(safe, subject, accounts, to, value, data, operation, fails) {
        let txFailed = fails || false

        // Estimate safe transaction (need to be called with from set to the safe address)
        let minGasEstimate = 0
        try {
            minGasEstimate = await safe.estimate.call(to, value, data, operation, {from: safe.address, gasPrice: 0})
            minGasEstimate = minGasEstimate.toNumber() + 10000
            console.log("    Min gas estimate: " + minGasEstimate)
        } catch(e) {
            console.log("    Could not estimate " + subject)
        }

        let nonce = await safe.nonce()
        let transactionHash = await safe.getTransactionHash(to, value, data, operation, minGasEstimate, MAX_GAS_PRICE, nonce)

        // Confirm transaction with signed messages
        let sigs = utils.signTransaction(lw, accounts, transactionHash)

        // Estimate gas of paying transaction
        let estimate = await safe.payAndExecuteTransaction.estimateGas(
            to, value, data, operation, minGasEstimate, MAX_GAS_PRICE, sigs.sigV, sigs.sigR, sigs.sigS
        )
        
        // Execute paying transaction
        // We add the minGasEstimate and an additional 10k to the estimate to ensure that there is enough gas for the safe transaction
        let tx = await safe.payAndExecuteTransaction(
            to, value, data, operation, minGasEstimate, MAX_GAS_PRICE, sigs.sigV, sigs.sigR, sigs.sigS, {from: executor, gas: estimate + minGasEstimate + 10000}
        )
        utils.checkTxEvent(tx, 'ExecutionFailed', safe.address, txFailed, subject)
        return tx
    }

    beforeEach(async function () {
        // Create lightwallet
        lw = await utils.createLightwallet()
        // Create Master Copies
        let proxyFactory = await ProxyFactory.new()
        let gnosisSafeMasterCopy = await GnosisSafe.new()
        gnosisSafeMasterCopy.setup([lw.accounts[0], lw.accounts[1], lw.accounts[2]], 2, 0, 0)
        // Create Gnosis Safe
        let gnosisSafeData = await gnosisSafeMasterCopy.contract.setup.getData([lw.accounts[0], lw.accounts[1], lw.accounts[2]], 2, 0, 0)
        gnosisSafe1 = utils.getParamFromTxEvent(
            await proxyFactory.createProxy(gnosisSafeMasterCopy.address, gnosisSafeData),
            'ProxyCreation', 'proxy', proxyFactory.address, GnosisSafe, 'create Gnosis Safe',
        )
        gnosisSafe2 = gnosisSafeMasterCopy;
        multiSend = await MultiSend.new()
    })

    it('should deposit and withdraw 1 ETH', async () => {
        // Deposit 1 ETH + some spare money for execution 
        assert.equal(await web3.eth.getBalance(gnosisSafe1.address), 0)
        await web3.eth.sendTransaction({from: accounts[0], to: gnosisSafe1.address, value: web3.toWei(1, 'ether')})
        assert.equal(await web3.eth.getBalance(gnosisSafe1.address).toNumber(), web3.toWei(1, 'ether'))

        let executorBalance = await web3.eth.getBalance(executor).toNumber()
        let tw = TransactionWrapper.at(1)
        let nestedTransactionData = '0x' + 
            tw.send.getData(accounts[0], web3.toWei(0.5, 'ether'), 0).substr(10) + 
            tw.send.getData(gnosisSafe2.address, web3.toWei(0.5, 'ether'), 0).substr(10)
        let data = await multiSend.contract.multiSend.getData(nestedTransactionData)
        // Withdraw 1 ETH
        await executeTransaction(gnosisSafe1, 'executeTransaction withdraw 0.5 ETH', [lw.accounts[0], lw.accounts[2]], multiSend.address, 0, data, DELEGATECALL)

        nestedTransactionData = '0x' + tw.send.getData(accounts[0], web3.toWei(0.5, 'ether'), 0).substr(10)
        data = await multiSend.contract.multiSend.getData(nestedTransactionData)
        await executeTransaction(gnosisSafe2, 'executeTransaction withdraw 0.5 ETH', [lw.accounts[0], lw.accounts[2]], multiSend.address, 0, data, DELEGATECALL)

        let executorDiff = await web3.eth.getBalance(executor) - executorBalance
        console.log("    Executor earned " + web3.fromWei(executorDiff, 'ether') + " ETH")
        assert.ok(executorDiff > 0)
    })
})
